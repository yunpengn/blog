<!DOCTYPE html><html class="theme-next gemini use-motion" lang="en"><head><meta name="generator" content="Hexo 3.9.0"><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#222"><link rel="stylesheet" href="/blog/lib/font-awesome/css/font-awesome.min.css?v=4.7.0"><link rel="stylesheet" href="/blog/css/main.css?v=7.2.0"><link rel="apple-touch-icon" sizes="180x180" href="/blog/images/favicon/apple-touch-icon.png?v=7.2.0"><link rel="icon" type="image/png" sizes="32x32" href="/blog/images/favicon/favicon-32x32.png?v=7.2.0"><link rel="icon" type="image/png" sizes="16x16" href="/blog/images/favicon/favicon-16x16.png?v=7.2.0"><link rel="mask-icon" href="/blog/images/favicon/safari_pinned_tab.svg?v=7.2.0" color="#222"><meta name="msapplication-config" content="/blog/images/favicon/browserconfig.xml"><script id="hexo.configurations">var NexT=window.NexT||{},CONFIG={root:"/blog/",scheme:"Gemini",version:"7.2.0",sidebar:{position:"left",display:"post",offset:12,onmobile:!1},back2top:{enable:!0,sidebar:!0,scrollpercent:!0},copycode:{enable:!0,show_result:!1,style:null},fancybox:!1,fastclick:!1,lazyload:!1,tabs:!0,motion:{enable:!0,async:!1,transition:{post_block:"fadeIn",post_header:"slideDownIn",post_body:"slideDownIn",coll_header:"slideLeftIn",sidebar:"slideUpIn"}},algolia:{applicationID:"",apiKey:"",indexName:"",hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}},translation:{copy_button:"Copy",copy_success:"Copied",copy_failure:"Copy failed"}}</script><meta name="description" content="In a previous post, we discussed how the various relational operators are implemented in relational database systems. If you have read that post, you probably still remember that there are a few alter"><meta name="keywords" content="Niu,Yunpeng,NUS,CS,Software,Developer"><meta property="og:type" content="article"><meta property="og:title" content="How Query Optimizer Works in RDBMS"><meta property="og:url" content="https://yunpengn.github.io/blog/2019/02/07/how-query-optimizer-works/index.html"><meta property="og:site_name" content="Yunpeng&#39;s Blog"><meta property="og:description" content="In a previous post, we discussed how the various relational operators are implemented in relational database systems. If you have read that post, you probably still remember that there are a few alter"><meta property="og:locale" content="en"><meta property="og:updated_time" content="2019-07-13T09:42:23.413Z"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="How Query Optimizer Works in RDBMS"><meta name="twitter:description" content="In a previous post, we discussed how the various relational operators are implemented in relational database systems. If you have read that post, you probably still remember that there are a few alter"><link rel="alternate" href="/blog/atom.xml" title="Yunpeng's Blog" type="application/atom+xml"><link rel="canonical" href="https://yunpengn.github.io/blog/2019/02/07/how-query-optimizer-works/"><script id="page.configurations">CONFIG.page={sidebar:""}</script><title>How Query Optimizer Works in RDBMS | Yunpeng's Blog</title><script async src="https://www.googletagmanager.com/gtag/js?id=UA-92228484-1"></script><script>var host=window.location.hostname;if("localhost"!==host){function gtag(){dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],gtag("js",new Date),gtag("config","UA-92228484-1")}</script><noscript><style>.sidebar-inner,.use-motion .brand,.use-motion .collection-title,.use-motion .comments,.use-motion .menu-item,.use-motion .motion-element,.use-motion .pagination,.use-motion .post-block,.use-motion .post-body,.use-motion .post-header{opacity:initial}.use-motion .logo,.use-motion .site-subtitle,.use-motion .site-title{opacity:initial;top:initial}.use-motion .logo-line-before i{left:initial}.use-motion .logo-line-after i{right:initial}</style></noscript></head><body itemscope itemtype="http://schema.org/WebPage" lang="en"><div class="container sidebar-position-left page-post-detail"><div class="headband"></div><header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-wrapper"><div class="site-meta"><div class="custom-logo-site-title"><a href="/blog/" class="brand" rel="start"><span class="logo-line-before"><i></i></span> <span class="site-title">Yunpeng's Blog</span> <span class="logo-line-after"><i></i></span></a></div><p class="site-subtitle">Life, coding and everything</p></div><div class="site-nav-toggle"><button aria-label="Toggle navigation bar"><span class="btn-bar"></span> <span class="btn-bar"></span> <span class="btn-bar"></span></button></div></div><nav class="site-nav"><ul id="menu" class="menu"><li class="menu-item menu-item-home"><a href="/blog/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i><br>Home</a></li><li class="menu-item menu-item-categories"><a href="/blog/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i><br>Categories</a></li><li class="menu-item menu-item-archives"><a href="/blog/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i><br>Archives</a></li><li class="menu-item menu-item-about"><a href="/blog/about/" rel="section"><i class="menu-item-icon fa fa-fw fa-user"></i><br>About</a></li></ul></nav></div></header><main id="main" class="main"><div class="main-inner"><div class="content-wrap"><div id="content" class="content"><div id="posts" class="posts-expand"><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><div class="post-block"><link itemprop="mainEntityOfPage" href="https://yunpengn.github.io/blog/blog/2019/02/07/how-query-optimizer-works/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content="Niu Yunpeng"><meta itemprop="description" content="The world never stops for you."><meta itemprop="image" content="/blog/images/avatar_cropped.jpg"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Yunpeng's Blog"></span><header class="post-header"><h1 class="post-title" itemprop="name headline">How Query Optimizer Works in RDBMS</h1><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i> </span><span class="post-meta-item-text">Posted on</span> <time title="Created: 2019-02-07 00:09:39" itemprop="dateCreated datePublished" datetime="2019-02-07T00:09:39+08:00">2019-02-07</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-calendar-check-o"></i> </span><span class="post-meta-item-text">Edited on</span> <time title="Modified: 2019-07-13 17:42:23" itemprop="dateModified" datetime="2019-07-13T17:42:23+08:00">2019-07-13</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-folder-o"></i> </span><span class="post-meta-item-text">In</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/blog/categories/Technical/" itemprop="url" rel="index"><span itemprop="name">Technical</span></a></span> , <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/blog/categories/Technical/Database/" itemprop="url" rel="index"><span itemprop="name">Database</span></a></span> , <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/blog/categories/Technical/Database/SQL/" itemprop="url" rel="index"><span itemprop="name">SQL</span></a></span> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-comment-o"></i> </span><span class="post-meta-item-text">Comments: </span><a href="/blog/2019/02/07/how-query-optimizer-works/#comments" itemprop="discussionUrl"><span class="post-comments-count disqus-comment-count" data-disqus-identifier="2019/02/07/how-query-optimizer-works/" itemprop="commentCount"></span></a></span><br></div></header><div class="post-body" itemprop="articleBody"><p>In a previous <a href="/blog/2019/01/05/relational-operators/" title="post">post</a>, we discussed how the various relational operators are implemented in relational database systems. If you have read that post, you probably still remember that there are a few alternative implementations for every operator. Thus, how should RDBMS determine which algorithm (or implementation) to use?</p><p>Obviously, to optimize the performance for any query, RDBMS has to select the correct the algorithm based on the query. It would not be desirable to always use the same algorithm. Also, SQL is a declarative language <em>(i.e., as a programmer we only declare what we want to do with the language, not tell how the language should accomplish the task)</em>. Therefore, it would be an anti-pattern if the user of the database system needs to specify which algorithm to use when writing the query. Instead, the correct approach would be that the user would treat the entire system as a blackbox. The end-user should not care about which algorithm is picked but expect the performance optimization is guaranteed.</p><a id="more"></a><h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>One tricky issue is about response time. Let‚Äôs say given a SQL query, you know all possible approaches to evaluate it. How should we find the optimal one? Without hesitation, you may answer that we can simply emuerate all of them and compare to see which one takes the shortest time. However, that is a terrible mistake. Let‚Äôs say there are 100 possible approaches, the best one takes 100ms while the worst one takes 1h. If you iterate through all of them, that probably already takes a few hours. Even after a few hours, you are still trying to find out which one is the optimal plan (i.e., the engine has not started the actual execution yet)! That would be even worse than randomly picking one of the approaches (i.e., in the worst case it would take 1h which is still better than iterating all plans).</p><p>In other words, you have to predict which approach is the best without actually executing and comparing them. Emm, that‚Äôs hard. But probably, we can look at the input data to predict which one works for the current input? That may not always work as well. If you have read a previous <a href="/blog/2019/01/20/understanding-database-storage/" title="post">post</a>, you may know that database stores index as well. Thus, probably we should read the indexes rather than the actual data records. I/Os in database systems are considered to be even more expensive than CPU costs. Thus, we have to make the prediction probably without seeing the data at all.</p><p>In this post, we would discuss an important component in RDBMS, <strong>query optimizer</strong>. Basically, it would <em>run some algorithms to determine which algorithm for the considered relational operator is optimal</em>. Strange? ü§î</p><h2 id="From-Query-to-Relational-Algebra"><a href="#From-Query-to-Relational-Algebra" class="headerlink" title="From Query to Relational Algebra"></a>From Query to Relational Algebra</h2><p>The input from SQL programmers are SQL queries. However, the SQL engine is more concerned with the format of relational algebra. Certainly, here we probably should call it ‚Äúextend relational algebra‚Äù as the classical algebra may not be enough.</p><p>To translate the SQL query into an equivalent relational algebra expression, we would decompose the query into smaller units called <em>‚Äúblocks‚Äù</em>. Then, the query optimizer would optimize on each <em>‚Äúblock‚Äù</em> basis. A single <em>‚Äúblock‚Äù</em> does not contain nesting parts and should have exactly one <code>SELECT</code> clause, exactly one <code>FROM</code> clause, at most one <code>WHERE</code> clause, at most one <code>GROUP BY</code> clause, and at most one <code>HAVING</code> clause. The <code>WHERE</code> clause should be in <strong>conjuctive normal form (CNF)</strong>, that is, a collection of <em>conjuncts</em> connected by <code>AND</code> logical operator. A <strong>conjunct</strong> contains one or more terms connected by <code>OR</code> logical operator.</p><p>It would be relatively trivial to convert each query block to relational algebra. Each <code>SELECT</code> clause would be mapping to projection, <code>WHERE</code> clause will be mapped to selection, <code>FROM</code> clause will be mapped to cross-product. And we assume <code>GROUP BY</code> and <code>HAVING</code> clauses as the extended operators in relational algebra.</p><h2 id="Estimating-the-Cost-of-a-Plan"><a href="#Estimating-the-Cost-of-a-Plan" class="headerlink" title="Estimating the Cost of a Plan"></a>Estimating the Cost of a Plan</h2><p>If we represent a query as a tree, there are two factors to consider when estimating the cost:</p><ul><li>The cost of performing the corresponding operation at each node;</li><li>The size of the operation result at each node;</li><li>Whether the result at a certain node is sorted (so that no need to sort again later).</li></ul><h3 id="The-Result-Size-of-an-Operation"><a href="#The-Result-Size-of-an-Operation" class="headerlink" title="The Result Size of an Operation"></a>The Result Size of an Operation</h3><p>In this section, we first focus on how the query optimizer could estimate the result size of an operation (using <em>system catalogs</em>). We have to understand this first because the other components of the overall cost depends on this. For instance, the cost of performing an operation usually depends on the input size. However, the input of an operator is probably the output of its <em>base operator</em>. Thus, we have to estimate the result size of its base operation at first.</p><p>To estimate the size of a given operation, we need to have some assumptions:</p><ul><li><strong>Uniformity</strong>: for each attribute, its values are distributed uniformly;</li><li><strong>Independence</strong>: for different attributes, the distribution is independent to each other;</li><li><strong>Inclusion</strong>: for convenience, if attribute <code>A</code> has fewer number of distinct values than <code>B</code>, we assume the distinct values of <code>A</code> form a subset of the distinct values of <code>B</code>.</li><li><strong>Preservation</strong>: due to <strong>independence</strong>, the result preserves all distinct values for attributes not in the selection and/or join predicates.</li></ul><p>We need the help of system catalogs to estimate result sizes. The system catalogs should contain information, including but not limited to:</p><ul><li>The number of tuples for each relation;</li><li>The size of per tuple for each relation;</li><li>The number of tuples per page for each relation;</li><li>The number of distinct values for each attribute;<ul><li>And probably the range of these distinct values if they are continuous.</li></ul></li><li>The height for each B+ tree index.</li></ul><p>We estimate the result size of an operation using the rules as follows:</p><ul><li><em>For an equality selection predicate:</em> the output size will be <code>1 / n</code> of the input size, where <code>n</code> is the number of distinct values on the selection attribute;</li><li><em>For a non-equality selection predicate:</em><ul><li>If we know the range of the values of the selection attribute, the output size will be <code>m / n</code> of the input size, where <code>m</code> is the number of distinct values left and <code>n</code> is the total number of distinct values;</li><li>If we are unaware of range of the values of the selection attribute, the output size will be <code>1 / 2</code> of the input size. This is a best-effort estimation.</li></ul></li><li><em>For an equality join predicate:</em><ul><li>Let‚Äôs say the number of tuples from the left relation <code>R1</code> is <code>p</code>, and the number of tuples from the right relation <code>R2</code> is <code>q</code>;</li><li>If the join predicate is <code>R1.A = R2.B</code>, the number of distinct values of attribute <code>A</code> is <code>m</code>, and the number of distinct values of attribute <code>B</code> is <code>n</code>;</li><li>Due to the <strong>inclusion</strong> assumption, we assume all <code>m</code> values of <code>A</code> form a subset of all <code>n</code> values of <code>B</code>;</li><li>The result size of this inner join would be <code>p * q / max(m, n)</code>;</li><li>For <em>key &amp; foreign key join</em>, let‚Äôs say <code>A</code> is the key column while <code>B</code> is the foreign key column, then the result size would be <code>q</code>.</li></ul></li></ul><p>The information stored in system catalogs would only guarantee <em>eventual consistency</em>. In other words, it would only be updated periodically (rather than being updated whenever there is a mutable operation on the database). This means the information is inaccurate. Anyway, we are just doing an estimation here. Due to the 3 assumptions above, the calculation is far from accuracy. The error would be more significant when propagating to higher level of the query plan tree.</p><p>To deal with the errors and the make the estimation more accurate, we can either:</p><ul><li>Maintain more detailed statistics (like using histogram, etc.);<ul><li>To capture correlation between 2 columns, we can use 2-dimensional histograms.</li></ul></li><li>Sample statistics of the intermediate query results at runtime (to reduce the effect of error propagation).</li></ul><h3 id="The-Cost-of-an-Operation"><a href="#The-Cost-of-an-Operation" class="headerlink" title="The Cost of an Operation"></a>The Cost of an Operation</h3><p>In this section, we discuss the cost of a single operation without considering the correlation between its parent &amp; child operations. Thus, the cost we computer here could be very different from its actual value in a complete query plan tree. This is primaily due to 2 reasons:</p><ul><li>The output of its base operator may have produced sorted result. Thus, if the current operation is sort-based, like sort-merge join, we can simply ignore the cost of the sort step;</li><li>The SQL engine is using a pipelined execution model (such as the Volcano iterator model mentioned later). In this case, some operations may be performed ‚Äúon-the-fly‚Äù (i.e., combined with its base operator) and does not incur any cost at all.</li></ul><p>Below, we first consider the cost of external sorting. Here, the implementation of external sorting is based on k-way merge algorithm. We assume the input has <code>n</code> pages and we have <code>r</code> buffer pages. Recall external sort needs two steps:</p><ul><li><em>Generate sorted runs:</em> we need to read all <code>n</code> pages and generate <code>n / r</code> sorted runs. Then, these sorted runs have to be written back to the hard disk. In total, we need <code>2n</code> page I/Os.</li><li><em>Merge sorted runs:</em> in each iteration, we can at most merge <code>r - 1</code> sorted runs into 1 run (i.e., use <code>r - 1</code> pages as input buffer and <code>1</code> page as output buffer). Thus, we need <code>log_(r - 1)^(n / r)</code> iterations and each iteration would need <code>2n</code> page I/Os.</li></ul><p>The cost calculation for external sorting is helpful since many other operations would involve the sorting step. Next, we compute the cost of other operations:</p><ul><li><em>Selection:</em> normally would need to scan the whole table, which means <code>n</code> page I/Os. However, it could usually be done ‚Äúon-the-fly‚Äù for pipelined evaluation. It can also be accelerated if the selection attribute has an index available.</li><li><em>Projection:</em> similar to selection. Need <code>n</code> page I/Os by right, but would be faster with pipelined evaluation or index.</li><li><em>Join:</em> depends on the join algorithm used. Let‚Äôs say left relation has <code>m</code> pages, right relation has <code>n</code> pages and we have <code>r</code> buffer pages. We use left table as the outer relation.<ul><li><em>Tuple-based nested loop join:</em> naive algorithm, should always use page-based instead;</li><li><em>Page-based nested loop join:</em> need <code>m + m * n</code> page I/Os;</li><li><em>Block-based nested loop join:</em> need <code>m + m * n / (r - 2)</code> page I/Os;<ul><li>We use <code>r - 2</code> because 1 page is used as inner relation buffer and 1 page is used as output buffer.</li></ul></li><li><em>Index-based nested loop join:</em> need <code>m * k</code> page I/Os, where <code>k</code> is the cost of index access path;</li><li><em>Sort-merge join</em>: sort step needs the same cost as external sorting (could ignore if the output of base operator is already sorted), merge step needs <em>at least</em> <code>m + n</code> page I/Os‚Äô;</li><li><em>Grace hash join</em>: partition step needs to read all pages and then write back to hard disk thus needs <code>2m + 2n</code> page I/Os, and join step needs <code>m + n</code> I/Os;</li></ul></li><li><em>Order by:</em> obviously, need to do external sorting;</li><li><em>Group by:</em> need to do sorting first which requires the same cost as external sorting, and produce the grouping ‚Äúon-the-fly‚Äù when writing back the sorted result;</li><li><em>Distinct:</em> similar to group by, do sorting first but only write one value from each group back to hard disk;</li><li><em>Set (intersection, union, difference):</em> sort-based approach (similar to sort-merge join) or hash-based approach (similar to Grace hash join).</li></ul><h3 id="Volcano-Iterator-Model"><a href="#Volcano-Iterator-Model" class="headerlink" title="Volcano Iterator Model"></a>Volcano Iterator Model</h3><p>Volcano Iterator Model is a popular implementation of SQL pipelined evaluation. To understand this model better, we can think of it as the <code>Iterator</code> interface in Java (i.e., see <code>java.util.Iterator</code>). It has 2 methods:</p><ul><li><code>hasNext</code>: to check whether we have finished the operation at this node. For example, it returns <code>false</code> when we have fully scanned the table;</li><li><code>next</code>: to produce the next page as the output of this node.</li></ul><p>Certainly, it should also have <code>open</code> and <code>close</code> methods to open &amp; close the resources needed for this operator (like file &amp; stream operations). Not all operations can be implemented with this iterator model (such as operators which require external sorting). Such operators are called ‚Äúblocking operators‚Äù.</p><p>This model brings one huge advantage: better response time. Let‚Äôs say there is a query plan tree with no blocking operators. The end user could get the 1st output page in <code>O(1)</code> time even if the overall cost may be <code>O(n)</code> or even higher. Further, this has 2 applicable scenarios:</p><ul><li>Let‚Äôs say the query contains a <code>LIMIT BY</code> clause. Using the iterator model means we only need to ‚Äúpay as you need‚Äù. If the query only wants the result of first 5 pages, we do not need to process the whole relation. In production systems, we suggest to ‚Äúprotect‚Äù all queries with <code>LIMIT BY</code> clause due to this reason;<ul><li>Note such ‚Äúprotection‚Äù will be invalidated if there exists blocking operators in the execution plan;</li><li>The use of <code>LIMIT BY</code> usually aligns with the business requirement as well since mostly the frontend would perform pagination anyway.</li></ul></li><li>The SQL server &amp; client could potentially establish a communication model similar to stream processing or message queue. Whenever the iterator model produces a new output page, the client would consume this new page. In this way, the overall latency of the system would be reduced.</li></ul><h2 id="Search-Space"><a href="#Search-Space" class="headerlink" title="Search Space"></a>Search Space</h2><p>Next, we discuss the search space of a query optimizer. Recall a query optimizer essentially attempts to find the fastest execution plan amont many potential plans. All these plans which are considered by the query optimizer form the <em>search space</em> of this optimizer.</p><p>Note a given query may have many possible execution plans, however, not all of them belong to the ‚Äúsearch space‚Äù. This is simply because there are way too many plans to consider. Thus, the search space is usually a subset of them. As shared in the previous <a href="/blog/2018/12/22/literature-review-join-reorder/" title="post">post</a>, this ‚Äúsubset‚Äù may consist of left deep trees, right deep trees or bushy trees.</p><p>How shall we generate these possible execution plans given an initial plan? Let‚Äôs visualize the execution plan as a tree, we can either:</p><ul><li>Change the order of the execution plan (i.e., swap the nodes in the tree);</li><li>Change the implementation method of a node in the tree.</li></ul><h2 id="Enumeration-Algorithm"><a href="#Enumeration-Algorithm" class="headerlink" title="Enumeration Algorithm"></a>Enumeration Algorithm</h2><p>Now, we already obtain the execution plans we need to consider and also know how to calculate the cost for each of them. It is time to enumerate through all of them and find our choice. Again, since there are too many plans to consider, it is nearly impossible to iterate through every one of them. In fact, query optimization is an NP-hard problem.</p><p>Similar to other NP-hard problems, there are a few categories of algorithms that can help us solve the challenge here:</p><ul><li>Exhaustive search<ul><li>only possible for queries with small number of relations (i.e., joins).</li></ul></li><li>Greedy algorithms<ul><li>apply some greedy heuristics, fast but could get bad results.</li></ul></li><li>Randomized algorithms<ul><li>such as iterative improvement (II) &amp; simulated annealing (SA).</li></ul></li><li>Dynamic programming<ul><li>most commercial systems apply this approach.</li></ul></li></ul><h2 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h2><p>To conclude, a query optimizer works based on 3 components: <strong>cost model</strong>, <strong>search space</strong>, <strong>enumeration algorithm</strong>. With careful design, the optimizer could hopefully avoid bad plans, although most likely the result would be sub-optimal. Without exhaustive search, it is not always possible to get the optimal plan.</p><p>The design of query optimizer is still an ongoing research topic. With the efforts of database researchers around the world, more and more innovations have been developed to improve the performance of SQL query optimizer.</p><h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><ul><li><a href="http://pages.cs.wisc.edu/~dbbook/" target="_blank" rel="noopener">Database Management Systems (3rd edition)</a></li><li><a href="https://paperhub.s3.amazonaws.com/dace52a42c07f7f8348b08dc2b186061.pdf" target="_blank" rel="noopener">Volcano - An Extensible and Parallel Query Evaluation System</a></li><li><a href="https://dl.acm.org/citation.cfm?id=98740" target="_blank" rel="noopener">Randomized Algorithms for Optimizing Large Join Queries</a></li></ul></div><div><ul class="post-copyright"><li class="post-copyright-author"><strong>Post author: </strong>Niu Yunpeng</li><li class="post-copyright-link"><strong>Post link: </strong><a href="https://yunpengn.github.io/blog/2019/02/07/how-query-optimizer-works/" title="How Query Optimizer Works in RDBMS">https://yunpengn.github.io/blog/2019/02/07/how-query-optimizer-works/</a></li><li class="post-copyright-license"><strong>Copyright Notice: </strong>All articles in this blog are licensed under <a href="https://creativecommons.org/licenses/by-nc-nd/4.0/" rel="noopener" target="_blank"><i class="fa fa-fw fa-creative-commons"></i>BY-NC-ND</a> unless stating additionally.</li></ul></div><footer class="post-footer"><div class="post-nav"><div class="post-nav-next post-nav-item"><a href="/blog/2019/01/20/understanding-database-storage/" rel="next" title="Understanding How is Data Stored in RDBMS"><i class="fa fa-chevron-left"></i> Understanding How is Data Stored in RDBMS</a></div><span class="post-nav-divider"></span><div class="post-nav-prev post-nav-item"><a href="/blog/2019/05/04/consistent-redis-sql/" rel="prev" title="Consistency between Redis Cache and SQL Database">Consistency between Redis Cache and SQL Database <i class="fa fa-chevron-right"></i></a></div></div></footer></div></article></div></div><div class="comments" id="comments"><div id="disqus_thread"><noscript>Please enable JavaScript to view the comments powered by Disqus.</noscript></div></div></div><div class="sidebar-toggle"><div class="sidebar-toggle-line-wrap"><span class="sidebar-toggle-line sidebar-toggle-line-first"></span> <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span> <span class="sidebar-toggle-line sidebar-toggle-line-last"></span></div></div><aside id="sidebar" class="sidebar"><div class="sidebar-inner"><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">Table of Contents</li><li class="sidebar-nav-overview" data-target="site-overview-wrap">Overview</li></ul><div class="site-overview-wrap sidebar-panel"><div class="site-overview"><div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="site-author-image" itemprop="image" src="/blog/images/avatar_cropped.jpg" alt="Niu Yunpeng"><p class="site-author-name" itemprop="name">Niu Yunpeng</p><div class="site-description motion-element" itemprop="description">The world never stops for you.</div></div><nav class="site-state motion-element"><div class="site-state-item site-state-posts"><a href="/blog/archives/"><span class="site-state-item-count">11</span> <span class="site-state-item-name">posts</span></a></div><div class="site-state-item site-state-categories"><a href="/blog/categories/"><span class="site-state-item-count">8</span> <span class="site-state-item-name">categories</span></a></div></nav><div class="feed-link motion-element"><a href="/blog/atom.xml" rel="alternate"><i class="fa fa-rss"></i> RSS</a></div><div class="links-of-author motion-element"><span class="links-of-author-item"><a href="https://github.com/yunpengn" title="GitHub &rarr; https://github.com/yunpengn" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a> </span><span class="links-of-author-item"><a href="https://www.facebook.com/NeilNiuYunpeng" title="Facebook &rarr; https://www.facebook.com/NeilNiuYunpeng" rel="noopener" target="_blank"><i class="fa fa-fw fa-facebook"></i>Facebook</a> </span><span class="links-of-author-item"><a href="https://sg.linkedin.com/in/yunpeng-niu/en" title="LinkedIn &rarr; https://sg.linkedin.com/in/yunpeng-niu/en" rel="noopener" target="_blank"><i class="fa fa-fw fa-linkedin"></i>LinkedIn</a> </span><span class="links-of-author-item"><a href="https://yunpengn.github.io/" title="Website &rarr; https://yunpengn.github.io/"><i class="fa fa-fw fa-globe"></i>Website</a></span></div><div class="cc-license motion-element" itemprop="license"><a href="https://creativecommons.org/licenses/by-nc-nd/4.0/" class="cc-opacity" rel="noopener" target="_blank"><img src="/blog/images/cc-by-nc-nd.svg" alt="Creative Commons"></a></div></div></div><div class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active"><div class="post-toc"><div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#Introduction"><span class="nav-number">1.</span> <span class="nav-text">Introduction</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#From-Query-to-Relational-Algebra"><span class="nav-number">2.</span> <span class="nav-text">From Query to Relational Algebra</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Estimating-the-Cost-of-a-Plan"><span class="nav-number">3.</span> <span class="nav-text">Estimating the Cost of a Plan</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#The-Result-Size-of-an-Operation"><span class="nav-number">3.1.</span> <span class="nav-text">The Result Size of an Operation</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#The-Cost-of-an-Operation"><span class="nav-number">3.2.</span> <span class="nav-text">The Cost of an Operation</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Volcano-Iterator-Model"><span class="nav-number">3.3.</span> <span class="nav-text">Volcano Iterator Model</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Search-Space"><span class="nav-number">4.</span> <span class="nav-text">Search Space</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Enumeration-Algorithm"><span class="nav-number">5.</span> <span class="nav-text">Enumeration Algorithm</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Conclusion"><span class="nav-number">6.</span> <span class="nav-text">Conclusion</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#References"><span class="nav-number">7.</span> <span class="nav-text">References</span></a></li></ol></div></div></div><div class="back-to-top motion-element"><i class="fa fa-arrow-up"></i> <span id="scrollpercent"><span>0</span>%</span></div></div></aside><div id="sidebar-dimmer"></div></div></main><footer id="footer" class="footer"><div class="footer-inner"><div class="copyright">&copy; 2017 ‚Äì <span itemprop="copyrightYear">2019</span> <span class="with-love" id="animate"><i class="fa fa-heart"></i> </span><span class="author" itemprop="copyrightHolder"><a href="https://yunpengn.github.io/" class="theme-link" rel="author" target="_blank">Niu Yunpeng</a></span></div><div class="powered-by">Powered by <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> v3.9.0</div><span class="post-meta-divider">|</span><div class="theme-info">Theme ‚Äì <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> v7.2.0</div></div></footer></div><script>"[object Function]"!==Object.prototype.toString.call(window.Promise)&&(window.Promise=null)</script><script src="/blog/lib/jquery/index.js?v=3.4.1"></script><script src="/blog/lib/velocity/velocity.min.js?v=1.2.1"></script><script src="/blog/lib/velocity/velocity.ui.min.js?v=1.2.1"></script><script src="/blog/js/utils.js?v=7.2.0"></script><script src="/blog/js/motion.js?v=7.2.0"></script><script src="/blog/js/affix.js?v=7.2.0"></script><script src="/blog/js/schemes/pisces.js?v=7.2.0"></script><script src="/blog/js/scrollspy.js?v=7.2.0"></script><script src="/blog/js/post-details.js?v=7.2.0"></script><script src="/blog/js/next-boot.js?v=7.2.0"></script><script>function loadCount(){var d=document,n=d.createElement("script");n.src="https://yunpeng.disqus.com/count.js",n.id="dsq-count-scr",(d.head||d.body).appendChild(n)}window.addEventListener("load",loadCount,!1)</script><script>var disqus_config=function(){this.page.url="https://yunpengn.github.io/blog/2019/02/07/how-query-optimizer-works/",this.page.identifier="2019/02/07/how-query-optimizer-works/",this.page.title="How Query Optimizer Works in RDBMS"};function loadComments(){var e=document,t=e.createElement("script");t.src="https://yunpeng.disqus.com/embed.js",t.setAttribute("data-timestamp",""+ +new Date),(e.head||e.body).appendChild(t)}window.addEventListener("load",loadComments,!1)</script></body></html>